package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.41

import (
	"context"
	"log/slog"
	"strconv"

	"github.com/oribe1115/peta/graph/gmodel"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// CreatePaste is the resolver for the createPaste field.
func (r *mutationResolver) CreatePaste(ctx context.Context, input gmodel.NewPaste) (*gmodel.Paste, error) {
	traPID, ok := ctx.Value("traPID").(string)
	if !ok || traPID == "" {
		return nil, gqlerror.Errorf("Need login")
	}

	paste, err := r.DB.CreateDB(traPID, input.Title, input.Content, input.Language)
	if err != nil {
		slog.Error(err.Error())
		return nil, gqlerror.Errorf("Internal server error")
	}

	return &gmodel.Paste{
		ID:        strconv.Itoa(paste.ID),
		Author:    paste.Author,
		Title:     paste.Title,
		Content:   paste.Content,
		Language:  paste.Language,
		CreatedAt: paste.CreatedAt,
	}, nil
}

// Paste is the resolver for the paste field.
func (r *queryResolver) Paste(ctx context.Context, id string) (*gmodel.Paste, error) {
	traPID, ok := ctx.Value("traPID").(string)
	if !ok || traPID == "" {
		return nil, gqlerror.Errorf("Need login")
	}

	idInt, err := strconv.Atoi(id)
	if err != nil {
		return nil, gqlerror.Errorf("Unexpected id format")
	}

	paste, err := r.DB.GetPaste(idInt)
	if err != nil {
		slog.Error(err.Error())
		return nil, gqlerror.Errorf("Internal server error")
	}

	if paste == nil {
		return nil, gqlerror.Errorf("Not found")
	}

	return &gmodel.Paste{
		ID:        strconv.Itoa(paste.ID),
		Author:    paste.Author,
		Title:     paste.Title,
		Content:   paste.Content,
		Language:  paste.Language,
		CreatedAt: paste.CreatedAt,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
